<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>PS5</title>
  <link rel="stylesheet" href="https://stackedit.io/style.css" />
</head>

<body class="stackedit">
  <div class="stackedit__left">
    <div class="stackedit__toc">
      
<ul>
<li><a href="#problem-set-5">Problem Set 5</a></li>
<li><a href="#beta-datapath">Beta Datapath</a>
<ul>
<li><a href="#beta-trivia-basic">β\betaβ Trivia (Basic)</a></li>
<li><a href="#beta-assembly-language-basic">β\betaβ Assembly Language (Basic)</a></li>
<li><a href="#non-beta-architecture-benchmarking-basic">Non β\betaβ Architecture Benchmarking (Basic)</a></li>
<li><a href="#clumsy-lab-assistant-basic">Clumsy Lab Assistant (Basic)</a></li>
<li><a href="#new-beta-instruction-basic">New Beta Instruction (Basic)</a></li>
<li><a href="#another-new-beta-instruction-basic">Another New Beta Instruction (Basic)</a></li>
<li><a href="#faulty-detection-in-beta-intermediate">Faulty Detection in Beta (Intermediate)</a></li>
<li><a href="#beta-instruction-replacements-intermediate">Beta Instruction Replacements (Intermediate)</a></li>
<li><a href="#pcsel-fault-detection-intermediate">PCSEL Fault Detection (Intermediate)</a></li>
</ul>
</li>
</ul>

    </div>
  </div>
  <div class="stackedit__right">
    <div class="stackedit__html">
      <p>50.002 Computation Structures<br>
Information Systems Technology and Design<br>
Singapore University of Technology and Design<br>
<strong>Natalie Agus (Fall 2020)</strong></p>
<h1 id="problem-set-5">Problem Set 5</h1>
<p>This page contains all practice questions that constitutes the topics learned in <ins>Week 5</ins>:  <strong>Beta Datapath</strong>.</p>
<p>Each topic’s questions are grouped into <strong>three</strong> categories: basic, intermediate, and challenging. You are recommended to do all basic problem set before advancing further.</p>
<h1 id="beta-datapath">Beta Datapath</h1>
<h2 id="beta-trivia-basic"><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>β</mi></mrow><annotation encoding="application/x-tex">\beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.8888799999999999em; vertical-align: -0.19444em;"></span><span class="mord mathdefault" style="margin-right: 0.05278em;">β</span></span></span></span></span> Trivia (Basic)</h2>
<ol>
<li>
<p>In an unpipelined Beta implementation, when is the signal <code>RA2SEL</code> set to <code>1</code>?</p>
<div class="collapsible">Show Answer</div><div class="content"><p>
The <code>RA2SEL</code>  signal is set to <code>1</code> when executing a <code>ST</code> instruction. When <code>RA2SEL</code> is <code>1</code> the 5-bit <code>Rc</code> field of the instruction is sent to the <code>RA2</code> port of the register file, causing <code>Reg[Rc]</code> to be sent to the <strong>write data port of main memory.</strong>
</p></div>
</li>
<li>
<p>In an unpipelined Beta implementation, when executing a <code>BR(foo,LP)</code> instruction to call procedure <code>foo</code>, what should <code>WDSEL</code> should be set to?</p>
 <div class="collapsible">Show Answer</div><div class="content"><p>
 <code>BR(foo,LP)</code> is a <i>macro</i> for <code>BEQ(R31,foo,LP)</code>. All <code>BNE/BEQ</code> instructions save the address of the following instruction in the specified destination register (<code>LP</code> in the example instruction). So <code>WDSEL</code> should be set <code>0</code>, selecting the output of the <code>PC+4</code> logic as the data to be <strong>written into the register file.</strong>
 </p></div>
</li>
<li>
<p>The <strong>minimum clock period</strong> of the unpipelined Beta implementation is determined by the <em>propagation</em> <em>delays</em> of the datapath elements and the amount of time it takes for the <strong>control signals to become valid</strong>. <strong>Which</strong> of the following select signals should become valid first in order to ensure the smallest possible clock period: <code>PCSEL, RA2SEL, ASEL, BSEL, WDSEL, WASEL</code>?</p>
 <div class="collapsible">Show Answer</div><div class="content"><p>
 To ensure the <strong>smallest</strong> possible clock period <code>RA2SEL</code> should become valid first. The <code>RA2SEL</code> mux must produce a <strong>stable register address</strong> before the register file can do its thing. All other control signals affect logic that operates <strong>after</strong> the required register values have been accessed, so they don't have to be valid until <i>later</i> in the cycle.
 </p></div>
</li>
</ol>
<h2 id="beta-assembly-language-basic"><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>β</mi></mrow><annotation encoding="application/x-tex">\beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.8888799999999999em; vertical-align: -0.19444em;"></span><span class="mord mathdefault" style="margin-right: 0.05278em;">β</span></span></span></span></span> Assembly Language (Basic)</h2>
<p>What does the following piece of Beta assembly do? Hand assemble the beta <strong>assembly language</strong> into <strong>machine language</strong>.</p>
<pre><code>I = 0x5678
B = 0x1234

LD(I,R0) -- (1)
SHLC(R0,2,R0) --  (2)
LD(R0,B,R1) -- (3)
MULC(R1,17,R1) -- (4)
ST(R1,B,R0)  -- (5)
</code></pre>
<p>Finally, <strong>what is the result stored in R0?</strong></p>
<div class="collapsible">Show Answer</div><div class="content"><p>
The machine language is:
</p><pre><code>I = 0x5678
B = 0x1234
|| LD(R31,I,R0) -&gt; 011000 00000 11111 0101 0110 0111 1000 
0x601F5678
|| SHLC(R0,2,R0) -&gt; 111100 00000 00000 0000 0000 0000 0010 
0xF0000002
||LD(R0,B,R1) -&gt; 011000 00001 00000 0001 0010 0011 0100
0x60201234
||MULC(R1,17,R1) -&gt; 110010 00001 00001 0000 0000 0001 0001
0xC8210011
||ST(R1,B,R0) -&gt; 011001 00001 00000 0001 0010 0011 0100
0x64201234</code></pre>
<p></p></div><p>Explanation:</p>
<ul>
<li>  <strong>Line 1:</strong> move the content of the memory unit at <code>EA=I</code> to register <code>R0</code></li>
<li>  <strong>Line 2:</strong> the content of <code>R0</code> is multiplied by 4 and stored back at register <code>R0</code>
</li><li>  <strong>Line 3:</strong> move the content of memory address <code>EA</code>: <code>EA</code>= <code>B</code> + content of register  <code>R0</code>; to register <code>R1</code>.
</li><li>  <strong>Line 4:</strong> The content of register <code>R1</code> is multiplied by 17 and stored back at register <code>R1</code>.
</li><li>  <strong>Line 5:</strong> Store / copy the content of register R1 to the memory unit with address <code>EA</code>: <code>EA</code>= <code>B</code> + content of register <code>R0</code>.
</li></ul>
The result of <code>R0</code> is the content of memory address I: <code>Mem[I]</code> multiplied by 4.

<h2 id="non-beta-architecture-benchmarking-basic">Non <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>β</mi></mrow><annotation encoding="application/x-tex">\beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.8888799999999999em; vertical-align: -0.19444em;"></span><span class="mord mathdefault" style="margin-right: 0.05278em;">β</span></span></span></span></span> Architecture Benchmarking (Basic)</h2>
<p>A local junk yard offers older CPUs with non-Beta architecture that require <strong>several clocks</strong> to execute each instruction. Here are the specifications:</p>
<p><span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mtable rowspacing="0.15999999999999992em" columnspacing="1em" rowlines="solid none none"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>Model</mtext></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>Clock&nbsp;Rate</mtext></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>Avg.&nbsp;clocks&nbsp;per&nbsp;Instruction</mtext></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>x</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mn>40</mn><mi>M</mi><mi>h</mi><mi>z</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>2.0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>y</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mn>100</mn><mi>M</mi><mi>h</mi><mi>z</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>10.0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>z</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mn>60</mn><mi>M</mi><mi>h</mi><mi>z</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>3.0</mn></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{matrix}
\text{Model} &amp; \text{Clock Rate} &amp;  \text{Avg. clocks per Instruction}\\
\hline
x &amp; 40 Mhz &amp; 2.0\\
y &amp; 100 Mhz &amp; 10.0\\
z &amp; 60 Mhz &amp; 3.0\\
\end{matrix}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 4.800000000000001em; vertical-align: -2.1500000000000004em;"></span><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 2.6500000000000004em;"><span class="" style="top: -4.65em;"><span class="pstrut" style="height: 4.65em;"></span><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 2.6500000000000004em;"><span class="" style="top: -4.8100000000000005em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord text"><span class="mord">Model</span></span></span></span><span class="" style="top: -3.61em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathdefault">x</span></span></span><span class="" style="top: -2.4099999999999997em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.03588em;">y</span></span></span><span class="" style="top: -1.2099999999999997em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.04398em;">z</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 2.1500000000000004em;"><span class=""></span></span></span></span></span><span class="arraycolsep" style="width: 0.5em;"></span><span class="arraycolsep" style="width: 0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 2.6500000000000004em;"><span class="" style="top: -4.8100000000000005em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord text"><span class="mord">Clock&nbsp;Rate</span></span></span></span><span class="" style="top: -3.61em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord">4</span><span class="mord">0</span><span class="mord mathdefault" style="margin-right: 0.10903em;">M</span><span class="mord mathdefault">h</span><span class="mord mathdefault" style="margin-right: 0.04398em;">z</span></span></span><span class="" style="top: -2.4099999999999997em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord mathdefault" style="margin-right: 0.10903em;">M</span><span class="mord mathdefault">h</span><span class="mord mathdefault" style="margin-right: 0.04398em;">z</span></span></span><span class="" style="top: -1.2099999999999997em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord">6</span><span class="mord">0</span><span class="mord mathdefault" style="margin-right: 0.10903em;">M</span><span class="mord mathdefault">h</span><span class="mord mathdefault" style="margin-right: 0.04398em;">z</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 2.1500000000000004em;"><span class=""></span></span></span></span></span><span class="arraycolsep" style="width: 0.5em;"></span><span class="arraycolsep" style="width: 0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 2.6500000000000004em;"><span class="" style="top: -4.8100000000000005em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord text"><span class="mord">Avg.&nbsp;clocks&nbsp;per&nbsp;Instruction</span></span></span></span><span class="" style="top: -3.61em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord">2</span><span class="mord">.</span><span class="mord">0</span></span></span><span class="" style="top: -2.4099999999999997em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord">1</span><span class="mord">0</span><span class="mord">.</span><span class="mord">0</span></span></span><span class="" style="top: -1.2099999999999997em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord">3</span><span class="mord">.</span><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 2.1500000000000004em;"><span class=""></span></span></span></span></span></span></span><span class="" style="top: -6.1000000000000005em;"><span class="pstrut" style="height: 4.65em;"></span><span class="hline" style="border-bottom-width: 0.05em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 2.1500000000000004em;"><span class=""></span></span></span></span></span></span></span></span></span></span></p>
<p>You are going to choose the machine which will execute your benchmark program the fastest, so you compiled and ran the benchmark on the three machines and counted the total instructions executed:</p>
<ol>
<li>
<p><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">x</span></span></span></span></span>: <code>3,600,000</code> instructions executed</p>
</li>
<li>
<p><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">y</span></span></span></span></span>: <code>1,900,000</code> instructions executed</p>
</li>
<li>
<p><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>z</mi></mrow><annotation encoding="application/x-tex">z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.04398em;">z</span></span></span></span></span>: <code>4,200,000</code> instructions executed</p>
</li>
</ol>
<p>Based on the above data, <strong>which machine would you choose?</strong></p>
<div class="collapsible">Show Answer</div><div class="content"><p>
First we find out the time taken to execute those instructions:
</p><ul>
<li>  $x$: $\frac{3.6M}{40M / 2}$ = $0.18$ seconds
</li><li> $y$: $\frac{1.9M} {100M / 10}$ = $0.19$ seconds
</li><li> $z$: $\frac{4.2M}{60M / 3}$ = $0.21$ seconds
</li></ul>
From the result above, $x$ is the fastest machine. Hence we choose $x$.
<p></p></div>
<h2 id="clumsy-lab-assistant-basic">Clumsy Lab Assistant (Basic)</h2>
<p>Notta Kalew, a somewhat fumble-fingered lab assistant, has deleted the opcode field from the following table describing the control logic of an unpipelined Beta processor.</p>
<img src="https://www.dropbox.com/s/hr0j3m2pmgbhvot/Q1.png?raw=1" width="70%" height="70%">
<ol>
<li>
<p>Help Notta out by identifying which Beta instruction is implemented by each row of the table.</p>
<div class="collapsible">Show Answer</div><div class="content"><p>
From first row to the last: <code>SUBC, BEQ, LDR, CMPEQ, ST</code>.
</p></div>
</li>
<li>
<p>Notta notices that <code>WASEL</code> is always zero in this table. Explain briefly under what circumstances <code>WASEL</code> would be non-zero.</p>
 <div class="collapsible">Show Answer</div><div class="content"><p>
 <code>WASEL</code> is <code>1</code> if an <i>interrupt, an illegal opcode is trapped, or a fault occurs</i>. When <code>WASEL</code> is <code>1</code>, it selects <code>XP</code> as the write address for the register file; <code>Reg[XP]</code> is where we store the current <code>PC+4</code>whenever there is an interrupt, a fault, or an illegal opcode.
 </p></div>
</li>
<li>
<p>Notta has noticed the following C code fragment appears frequently in the benchmarks:</p>
<pre><code>int *_p; /_* Pointer to integer array *_/_
_int i,j; /_* integer variables *_/_

_..._

_j = p[i]; /_* access ith element of array */
</code></pre>
<p>The pointer variable <code>p</code> contains the <em>address</em> of a <strong>dynamically allocated</strong> array of integers. The value of <code>p[i]</code> is stored at the address <code>Mem[p +4i]</code> where <code>p</code> and <code>i</code> are locations containing the values of the corresponding C variables. On a conventional Beta this code fragment is translated to the following instruction sequence:</p>
<pre><code>LD(...,R1)     /* R1 contains p, the array base address */
LD(...,R2)     /* R2 contains I, the array index */    ...
SHLC(R2,2,R0)  /* compute byte-addressed offset = 4*i */
ADD(R1,R0,R0)  /* address of indexed element */
LD(R0,0,R3)    /* fetch p[i] into R3 */
</code></pre>
<p>Notta proposes the addition of an <code>LDX</code> instruction that shortens the last three instructions to:</p>
<pre><code>SHLC(R2,2,R0)  /* compute byte-addressed offset = 4*i */
LDX(R0,R1,R3)  /* fetch p[i] into R3 */
</code></pre>
<p>Give a <em><strong>register-transfer language description</strong></em> for the <code>LDX</code> instruction.</p>
 <div class="collapsible">Show Answer</div><div class="content"><p>
 </p><pre><code>LDX( Ra, Rb, Rc ):
 	EA &lt;- Reg[Ra] + Reg[Rb]
 	Reg[Rc] &lt;- Mem[EA]
 	PC &lt;- PC + 4</code></pre><p></p></div>
</li>
<li>
<p>Using a table like the one above specify the control signals for the LDX opcode.</p>
 <div class="collapsible">Show Answer</div><div class="content"><p>
 $$\begin{matrix}
 PCSEL &amp; RA2SEL &amp; ASEL &amp; BSEL&amp; WDSEL &amp; ALUFN &amp; WR &amp; WERF &amp; WASEL \\
 \hline
 0 &amp; 0 &amp; 0 &amp; 0 &amp; 2 &amp; ADD &amp; 0 &amp; 1 &amp; 0 \end{matrix}$$
 </p></div>
</li>
<li>
<p>It occurs to Notta that adding an <code>STX</code> instruction would probably be useful too. Using this new instruction, <code>p[i] = j</code> might compile into the following instruction sequence:</p>
<pre><code>SHLC(R2,2,R0)  /* compute byte-addressed offset = 4*i */
STX(R3,R0,R1)  /* R3 contains j, R1 contains p */
</code></pre>
<p>Briefly describe what (hardware) <strong>modifications</strong> to the Beta datapath would be necessary to be able to execute <code>STX</code> in a <strong>single cycle.</strong></p>
 <div class="collapsible">Show Answer</div><div class="content"><p>
 The register transfer language description of  <code>STX</code> would be:
 </p><pre><code>STX(Rc, Rb, Ra)
 EA &lt;- Reg[Ra] + Reg[Rb]
 Mem[EA] &lt;- Reg[Rc]
 PC &lt;- PC + 4</code></pre>
 It's evident that we need to perform <strong>3 register reads,</strong> but the Beta's register file has only <strong>2 read ports.</strong> Thus we need to add a <strong>third read port</strong> to the register file.
 <br><br>
 Incidentally, adding a third read port would eliminate the need for the <code>RA2SEL</code> mux because we <i>no longer need to choose between <code>Rb</code> and <code>Rc</code></i>, since each register field has its own read port.
 <p></p></div>
</li>
</ol>
<h2 id="new-beta-instruction-basic">New Beta Instruction (Basic)</h2>
<ol>
<li>
<p>Write the register transfer language below corresponds to the instruction with the following control signal:</p>
 <img src="https://www.dropbox.com/s/ysf5rtc0d9mwsil/ctrlnew.png?raw=1" width="20%" height="20%">
 <div class="collapsible">Show Answer</div><div class="content"><p>
 </p><pre><code>PC &lt;-- PC + 4
 Reg[Rc] &lt;-- (PC+4)+4*SXT(C) </code></pre>
 <p></p></div>
</li>
<li>
<p>Explain why the following instruction cannot be added to our Beta instruction set without further hardware modifications on the datapath:</p>
<pre><code>PUSH(Rc, 4, Ra):
	Mem[Reg[Ra]] &lt;-- Reg[Rc]
	Reg[Ra] &lt;-- Reg[Ra] + 4
</code></pre>
 <div class="collapsible">Show Answer</div><div class="content"><p>
 To implement this <code>PUSH</code>, somehow the <code>ALU</code> would have to produce <i>two</i> 32-bit values instead of the original one 32-bit output. The new two 32-bit values are: <code>Reg[Ra]</code> to be used as the memory address and <code>Reg[Ra]+4</code> to be written into the register file.
 </p>
</div></li>
</ol>
<h2 id="another-new-beta-instruction-basic">Another New Beta Instruction (Basic)</h2>
<p>Given the following C-code:</p>
<pre><code>if (a != 0){ 
	b = 3;
}  
(other code....)
</code></pre>
<p>where <code>a</code>, <code>b</code> are variables that have been initialised in the earlier part of the code (not shown). If we were to implement the following C-code using the Beta instruction set, we must do this in at least <strong>two</strong> cycles:</p>
<pre><code>BEQ(Ra, label_continue, R31)  
ADDC(R31, 3, Rb)  
label_continue: (other code)
</code></pre>
<p>where <code>Ra</code>, <code>Rb</code> are assumed to be registers <strong>containing</strong> values <code>a</code> and <code>b</code>.</p>
<p>The <code>ALU</code> in this particular  Beta however, implements <em>five</em> new functions on top of the standard functions: <code>“B”, “NOTA”, “NOTB”, “TRUE”, “FALSE”</code>.</p>
<p>Due to this, your classmate suggested that we can actually do this in <strong>one</strong> cycle by modifying the <code>Control Unit</code> to accept  this <strong>new instruction</strong> called <code>MCNZ</code> (move constant if not zero) instead:</p>
<pre><code>MCNZ(Ra, literal, Rc) : 
	if(Reg[Ra] != 0)
		Reg[Rc] &lt;-- literal 
	PC &lt;-- PC + 4
</code></pre>
<p>What values should the Control Unit give for this instruction <code>MCNZ</code>?</p>
<div class="collapsible">Show Answer</div><div class="content"><p>
$$\begin{matrix}
	PCSEL &amp; RA2SEL &amp; ASEL &amp; BSEL&amp; WDSEL &amp; ALUFN &amp; WR &amp; WERF &amp; WASEL \\
	\hline
	0 &amp; - &amp; - &amp; 1 &amp; 1 &amp; "B" &amp; 0 &amp; Z?0:1 &amp; 0 \end{matrix}$$
<br>
Note: <code>Z?0:1</code> -- means <code>0</code> if <code>Z==1</code>, and <code>1</code> otherwise.
</p></div>
<h2 id="faulty-detection-in-beta-intermediate">Faulty Detection in Beta (Intermediate)</h2>
<p>You suspected that your Beta CPU is faulty, in particular, these two components:</p>
<ul>
<li>
<p>The <code>ASEL</code> <strong>mux</strong> might be faulty:</p>
<ul>
<li>if <code>ASEL = 0</code>, the output is always 0.</li>
<li>There’s no problem if <code>ASEL = 1</code>.</li>
</ul>
</li>
<li>
<p>The part of the <code>CU</code> that gives out <code>RA2SEL</code> signal might be faulty:</p>
<ul>
<li><code>RA2SEL</code> is always <strong>stuck at <code>0</code></strong> (it cannot be <code>1</code> regardless of the instruction)</li>
</ul>
</li>
</ul>
<p>Your friend came up with several short test programs. You want to select one of these programs to run in the faulty Beta, but you don’t want to waste your time loading and running multiple programs and would like to select one that can <strong>detect both faults</strong>. Which of the following program(s) can detect <strong>both faults?</strong></p>
<p><em>Meaning that :</em></p>
<ol>
<li>
<p>The values in the <code>PC</code> / Registers in Regfile / Memory Unit will be <em>different</em> from a working Beta CPU if these programs were to be executed in this faulty Beta.</p>
</li>
<li>
<p>You can be 100% sure the discrepancy is caused by <strong>both</strong> <code>RA2SEL</code> signal or <code>ASEL</code> mux faulty.</p>
</li>
<li>
<p>Programs that can only detect the <code>RA2SEL</code> signal faulty but not <code>ASEL</code> multiplexer faulty (or vice versa) is <strong>not acceptable</strong>.</p>
</li>
</ol>
<p><em>You can assume that the initial content of all registers are <code>0</code>.</em></p>
<p><strong>Program 1</strong>:</p>
<pre><code>.=0x000  
LDR(constant, R0) 
LDR(constant + 4, R1) 
ADD(R0, R1, R2)  
ST(R2, constant + 8, R31) 
HALT()  

constant: LONG(8)
LONG(4)
</code></pre>
<p><strong>Program 2</strong>:</p>
<pre><code>.=0X000  
CMOVE(5, R1) 
LDR(constant, R2) 
ST(R2, answer, R31) 
MUL(R1, R2, R3) 
HALT()  

constant: LONG(0) 
.=0xFFFC  
answer: LONG(0)
</code></pre>
<p><strong>Program 3</strong>:</p>
<pre><code>.=0x000  
constant: LONG(8)
LONG(4)
LDR(constant, R0) 
ADD(R0, R0, R0) 
ST(R0, .+8, R31) 
HALT()
</code></pre>
<p><strong>Program 4</strong>:</p>
<pre><code>.=0x000  
CMOVE(5, R0)  
ST(R0, constant + 8, R31) 
LDR(constant, R1)  
ADD(R1, R1, R2)  
HALT()  

.=0xABCC  
constant: LONG(8)
LONG(4)
</code></pre>
<div class="collapsible">Show Answer</div><div class="content"><p>
There's only one instruction: <code>ST</code> that requires <code>RA2SEL</code> to be <code>1</code>. Therefore our program must have this instruction to test against a working Beta CPU. We also must ensure that we utilize instructions that results in <code>ASEL=0</code> and that the output of the <code>ASEL</code> mux should be nonzero in a working Beta CPU. We also need to ensure that the programs need to <i>utilize</i> these instructions in a way that results in a different <strong>state</strong> when run on a working Beta CPU.   
<br><br>
<strong>Program 1</strong> and <strong>Program 4</strong> fulfills the criteria, and the other two don't. 
<br><br>
For <strong>Program 1</strong>:
* The content store at <code>R2</code> will be 4 instead of 12 if the <code>ASEL</code> mux is faulty. 
</p><ul>
<li> We will end up storing 8 instead of 12 to <code>Mem[constant + 8]</code> if <code>RA2SEL</code> signal remains <code>0</code> due to the faulty <code>CU</code>. </li>
</ul>
For <strong>Program 4</strong>:
<ul>
<li> The content of <code>R21</code>  is stored to <code>Mem[Constant+8]</code> instead of the content of <code>R0</code>. Therefore, <code>Mem[Constant+8]</code>  is <code>0</code> instead of <code>5</code>.</li>
<li> The content of <code>R2</code> is <code>8</code> instead of <code>16</code>.</li>
</ul>
<strong>Program 2</strong> and <strong>Program 3</strong> also utilizes <code>ST</code> and <code>OP</code> instructions: <code>MUL</code>/<code>ADD</code>, etc that involve the <code>ASEL</code> mux but if you run them with the faulty Beta and with a working Beta, the end state is either the same or different due to one of the faulties only, and therefore can't be used to detect both faulties. 
<p></p></div>
<h2 id="beta-instruction-replacements-intermediate">Beta Instruction Replacements (Intermediate)</h2>
<p>For each of the statements below, indicate whether they’re True or False and provide your reasoning.</p>
<ul>
<li>
<p><strong>Statement 1:</strong>  In the Beta, every <code>ADDC</code> instruction can <strong>always</strong> be replaced by a <code>SUBC</code> instruction that puts precisely the <strong>same</strong> value in the destination register. For example, <code>ADDC(R0,1,R0)</code> is equal to <code>SUBC(R0,-1,R0)</code> (<em>think about all constants</em>).</p>
</li>
<li>
<p><strong>Statement 2:</strong> In a Beta program, you can use <code>BEQ(R31, label, R31)</code> as a substitute for <code>JMP(Ra)</code> where <code>Ra</code> stores the address of <code>label</code>, no matter where <code>label</code> is.</p>
</li>
<li>
<p><strong>Statement 3:</strong> We can never perform <code>LD</code> and <code>ST</code>  to any two independent addresses in a <em>single cycle</em> (even if the memory unit supports it) by just modifying the <strong>control unit</strong> of the Beta. In other words, we need to modify the datapath of the Beta in order to do this.</p>
</li>
</ul>
<div class="collapsible">Show Answer</div><div class="content"><p>
<strong>Statement 1 is False</strong>. We can have <code>ADDC(R0, -65536, R0)</code> but we cant have <code>SUBC(R0, 65536, R0)</code> as the most positive number that a signed 16-bit can represent is <code>65535</code>. 
<br>
<br>
<strong>Statement 2 is False</strong>. <code>Ra</code> contains 32-bit of data, so we can set <code>PC</code> to be pointing to <i>any</i> address in the memory (4GB of address space) with <code>JMP(Ra)</code>. However, <code>BEQ</code> only covers <code>65536*4</code> (above <code>PC+4</code>) + <code>65535*4</code> (*below and inclusive of <code>PC+4</code>*) bytes of address space.
<br>
<br>
<strong>Statement 3 is True</strong>. The output of the <code>ALU</code> supplies a <strong>single</strong> address for both load and store to the memory unit. </p></div>
<h2 id="pcsel-fault-detection-intermediate">PCSEL Fault Detection (Intermediate)</h2>
<p>This time round, consider a Beta machine with a faulty <strong>control unit</strong>, where its <code>PCSEL</code> signal is always <code>0</code>, meaning that the input to the <code>PC</code> register is always<br>
<code>PC+4</code> <em>regardless</em> of the instruction.</p>
<p>As always, we can  detect this particular fault by running a simple test program written in Beta assembly language. State which of the following programs can <strong>detect</strong> this particular fault, meaning that if it was to be run on a faulty Beta machine, we will get different results (contents) on the registers in the regfiles, PC, or Memory Unit, and provide your reasoning.</p>
<p>Assume that all register values were <code>0</code> at the beginning of each program execution.</p>
<p><strong>Program 1</strong>: (executed for two CLK cycles)</p>
<pre><code>.= 0  
BEQ(R0, .+4, R31)  
ADDC(R0, 1, R0)  
</code></pre>
<p><strong>Program 2</strong>: (executed for three CLK cycles)</p>
<pre><code>.=0  
CMPEQ(R0, R0, R0)  
BNE(R0, .-4, R31)  
ADDC(R0, 1, R0)
</code></pre>
<p><strong>Program 3</strong>: (executed for four CLK cycles)</p>
<pre><code>.=0  
LD(R0, 0, R0)  
MULC(R0, 1, R0)  
BNE(R0, .+4, R31)  
CMPEQ(R0, R31, R2)
</code></pre>
<p><strong>Program 4</strong>: (executed for two CLK cycles)</p>
<pre><code>.=0
ST(R0, x, R31) 
x: LONG(12)
</code></pre>
<p><strong>Program 5</strong>: (executed for two CLK cycles)</p>
<pre><code>.=0  
JMP(R1)  
ADDC(R0, 1, R1)
</code></pre>
<p><strong>Program 6</strong>: (executed for two CLK cycles)</p>
<pre><code>.=0  
LDR(R31, .+8, R0)  
ADDC(R0, 1, R1)  
x : LONG(3)
</code></pre>
<div class="collapsible">Show Answer</div><div class="content"><p>
Program 2, 4, and 5 can successfully <strong>detect</strong> this faulty. All of them forces the control unit to produce non-zero <code>PCSEL</code>. For example, <strong>Program 4</strong> results in <code>illop</code> when the Beta attempts to execute <code>LONG(12)</code> because it isn't an instruction. Therefore <code>PCSEL=3</code> if the control unit works properly and that the content of <code>PC</code> will be <code>ILLOP</code> (wherever the address of illegal operation handler is) instead of address <code>0xC</code>. </p></div>
<h3 id="quality-control-intermediate">Quality Control (Intermediate)</h3>
<p>One Beta manufacturer is having quality-control problems with their design. In particular, they’ve had reliability issues with various device connections that are circled in the diagram below.</p>
<img src="https://www.dropbox.com/s/i71imaa2toxsnk7/betafault.png?raw=1" width="70%" height="70%">
<p>Your job is to <strong>write some test programs</strong> to help determine if a machine is fault-free. <mark>Assume that when a device connection is “faulty,” the indicated <strong>bus or signal</strong> is always <strong>producing</strong> “0” instead of the <em>expected value</em>.</mark></p>
<p><strong>For each</strong> of the circled connections, <strong>write an instruction sequence</strong> that when executed for a <strong>specified number of cycles</strong> will leave the following result in <code>R0</code>:</p>
<ul>
<li><code>1</code> in <code>R0</code> if the connection was working.</li>
<li>Other values in <code>R0</code> if the connection was faulty.</li>
</ul>
<p><em>You can assume that all registers are reliably set to 0 before each sequence is executed.</em></p>
<p>Give your instruction sequence for each of the six indicated faults and briefly <strong>explain</strong> how each sequence detects the fault and produces something besides <code>1</code> in <code>R0</code> when the fault is present:</p>
<ul>
<li><strong>Fault A:</strong> Input 1 of <code>PCSEL</code> mux has a value of <code>0</code> instead of <code>PC+4+4*SEXT(C)</code>.</li>
<li><strong>Fault B:</strong> <code>RA2SEL</code> multiplexer control signal is <code>0</code> instead of as per intended current instruction <code>OPCODE</code>.</li>
<li><strong>Fault C:</strong> <code>Z</code> input to control logic is always <code>0</code> instead of the correct value depending on <code>RD1</code>.</li>
<li><strong>Fault D:</strong>   <code>BSEL</code> multiplexer control signal <code>0</code>  instead of as per intended current instruction <code>OPCODE</code>.</li>
<li><strong>Fault E:</strong> <code>WR</code> memory control signal is <code>0</code>  instead of as per intended current instruction <code>OPCODE</code>.</li>
<li><strong>Fault F:</strong> Input 0 of <code>WDSEL</code> mux has a value of <code>0</code> instead of <code>PC+4</code>.</li>
</ul>
<p><i>Note: there’s many alternate answers. They aren’t unique.</i></p>
<p><strong>Fault A:</strong> Input 1 of <code>PCSEL</code> mux has a value of <code>0</code> instead of <code>PC+4+4*SEXT(C)</code>.</p>
<div class="collapsible">Show Answer</div><div class="content"><p>
</p><pre><code>| starts at address 0
. = 0
BEQ(R0,.+4,R31) | 0x0
ADDC(R0,1,R0) | 0x4
</code></pre>
<br>
Execute for 2 cycles (i.e., execute two instructions):
<ul>
<li> If fault A is not present, <code>R0</code> contains <code>1</code> after the second cycle, since the second instruction is fetched from location <code>0x4</code>. </li>
<li> If fault A is present, the second instruction is fetched from location <code>0</code> (instead of <code>4</code>, since the input <code>1</code> to the <code>PCSEL</code> mux is <code>0</code>), so the value of <code>R0</code> stays <code>0</code>.
</li></ul>
<br>
Note that the label <code>.+4</code> means “memory location of current instruction + 4”, which is <code>0+4</code> here.
<p></p></div>
<p><strong>Fault B:</strong> <code>RA2SEL</code> multiplexer control signal is <code>0</code> instead of as per intended current instruction <code>OPCODE</code>.</p>
<div class="collapsible">Show Answer</div><div class="content"><p>
</p><pre><code>| starts at address 0
. = 0
ADDC(R1,1,R1)
ST(R1,0,R0)
LD(R0,0,R0)
</code></pre>
Execute for 3 cycles:
<ul>
<li> If fault B is not present, the <code>ST</code> instruction writes the value <code>1</code> into location <code>0</code>, which is then <code>LD</code>-ed (loaded) into <code>R0</code>.</li>
<li> If fault B is present, the <code>ST</code> instruction writes the contents of <code>R0</code> instead (ie, the value <code>0</code>), so now the <code>LD</code> instruction puts <code>0</code> into <code>R0</code>.</li> 
</ul><p></p></div>
<p><strong>Fault C:</strong> <code>Z</code> input to control logic is always <code>0</code> instead of the correct value depending on <code>RD1</code>.</p>
<div class="collapsible">Show Answer</div><div class="content"><p>
</p><pre><code>| starts at address 0
. = 0
BEQ(R0,.+8,R31)
ADDC(R0,0,R0)
ADDC(R0,1,R0)
</code></pre>
Execute for 2 cycles:
<ul>
<li> If fault C is not present, <code>R0</code> is incremented to <code>1</code> since the branch to memory location <code>8</code> is taken.</li> 
<li> If fault C is present, the <code>BEQ</code> instruction never branches, executing the instruction at location <code>4</code>, which leaves the contents of <code>R0</code> unchanged (i.e., it's still <code>0</code>).</li>
</ul>
<p></p></div>
<p><strong>Fault D:</strong> <code>BSEL</code> multiplexer control signal <code>0</code>  instead of as per intended current instruction <code>OPCODE</code>.</p>
<div class="collapsible">Show Answer</div><div class="content"><p>
</p><pre><code>| starts at address 0
. = 0
ADDC(R0,1,R0)
</code></pre>
Execute for 1 cycle:
<ul>
<li>If fault D is not present, <code>R0</code> is increment to <code>1</code>. </li>
<li> If fault D is present, the high-order 5-bits of the literal field (i.e., where <code>Rb</code> is encoded) is used as a register address, and the contents of that register is added to <code>R0</code>. Since the literal is <code>1</code>, the second register is <code>R0</code> (containing <code>0</code>), so the value written into <code>R0</code> is <code>0</code>.</li>
</ul><p></p></div>
<p><strong>Fault E:</strong> <code>WR</code> memory control signal is <code>0</code>  instead of as per intended current instruction <code>OPCODE</code>.</p>
<div class="collapsible">Show Answer</div><div class="content"><p>
</p><pre><code>| starts at address 0
. = 0
ADDC(R1,1,R1)
ST(R1,X,R31)
LD(R31,X,R0)
. = 0x100
X: LONG(0)
</code></pre>
Execute for 3 cycles:
<ul>
<li> If fault E is not present, the  instruction writes the value <code>1</code>  into <code>Mem[X]</code>, which is then <code>LD</code>-ed (loaded) into <code>R0</code>. </li>
<li> If fault E is present, the <code>ST</code> instruction has no effect, so now the <code>LD</code> instruction loads the original value of location <code>X</code> into <code>R0</code>.</li>
</ul>
<p></p></div><p><strong>Fault F:</strong> Input 0 of <code>WDSEL</code> mux has a value of <code>0</code> instead of <code>PC+4</code>.</p>
<div class="collapsible">Show Answer</div><div class="content"><p>
</p><pre><code>| starts at address 0
. = 0
BEQ(R0,.+4,R1)
SUBC(R1,3,R0)
</code></pre>
Execute for 2 cycles:
<ul>
<li> If fault F is not present, the <code>BEQ</code> instruction loads <code>4</code> into <code>R1</code> and the <code>SUBC</code> loads <code>1</code> into <code>R0</code>.</li>
<li> If fault F is present, the <code>BEQ</code> instruction loads <code>4</code> (which is the current <code>PC + 4</code>) into <code>R1</code> and the <code>SUBC</code> loads 8 (which is the current <code>PC+4</code>) into <code>R0</code>.</li>
</ul>
<i>Shorter alternative:</i>
<pre><code>| starts at address 0
. = 0
ADDC(R0,1,R0)
</code></pre>
Execute for 1 cycle:
<ul>
<li> If fault F is not present, the <code>ADDC</code> instruction will write <code>1</code> into <code>R0</code>,</li>
<li> Otherwise, <code>4</code> (which is the current <code>PC+4</code>) will be written into <code>R0</code>.</li>
</ul>
<p></p></div>

    </div>
  </div>
<script>
var coll = document.getElementsByClassName("collapsible");
var i;

for (i = 0; i < coll.length; i++) {
  coll[i].addEventListener("click", function() {
    this.classList.toggle("active");
    var content = this.nextElementSibling;
    if (content.style.display === "block") {
      content.style.display = "none";
    } else {
      content.style.display = "block";
    }
  });
}
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"] ],
        processEscapes: true
      }
    });
  </script>
  <script
    type="text/javascript"
    charset="utf-8"
    src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"
  >
  </script>
  <script
    type="text/javascript"
    charset="utf-8"
    src="https://vincenttam.github.io/javascripts/MathJaxLocal.js"
  >
  </script>
</body>

<style>
.blueborder{
 border-style:solid;
 border-color:#287EC7;
 padding: 10px;
}

.redborder{
 border-style:solid;
 border-color:#FF0000;
 padding: 10px;
}


.greenbox{
background-color: #cfc ;
padding: 10px; 
border: 1px solid green;
}

.orangebox{
background-color: #FFE4B5 ;
padding: 10px; 
border: 1px solid #FF8C00;
}

.redbox{
    background-color: #FFE4E1;
    border: 1px solid #FA8072;
    display: block;
    padding: 10px;
}

.bluebox{
    background-color: #F0F8FF;
    border: 1px solid #87CEFA;
    display: block;
    padding: 10px;
}

.yellowbox{
    background-color: #FFFACD;
    border: 1px solid #FFFF66;
    display: block;
    padding: 10px;
}

.redtext{
	color:red;
}

.bluetext{
	color:blue;
}

.orangetext{
	color:#FF791A;
}

.greentext{
	color:green;
}



/* Style the button that is used to open and close the collapsible content */
.collapsible {
  background-color: #efffef;
  color: #444;
  cursor: pointer;
  padding: 10px;
  border: none;
  text-align: left;
  outline: none;
  font-size: 15px;
  font-weight: bold;
}

/* Add a background color to the button if it is clicked on (add the .active class with JS), and when you move the mouse over it (hover) */
.active, .collapsible:hover {
  background-color: #ccffcc;
}

/* Style the collapsible content. Note: hidden by default */
.content {
  padding: 0 10px;
  display: none;
  overflow: hidden;
  background-color: #efffef;
}
</style>




</html>
